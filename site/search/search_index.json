{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Welcome to MkDocs"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"01.%20Introduction%20and%20Goals/","text":"Introduction and Goals Vision \"Enable direct communication between users and agents for an improved service satisfaction\" Requirements Overview Why Improve user satisfaction by enabling them to receive quick solutions for their problems Reduce the effort to create a new ticket for a customer / gather all required information to solve a ticket How Reusing existing functionality to quickly create new processes Including in new POWA client What Integrate Messaging (former Smoope) into Processes Quality Goals Priority Quality Goal Scenario 1 Configurability It should be easy to install and configure Messaging for/on customer environments 2 Monitoring The integration should provide logging and monitoring mechanism based on the \"Book of play\" Stakeholders Role/Name Contact Expectations Product Owner Halil Mandal Messaging is completely integrated in Processes and provides added value Platform Integration Manager Christian Pesch The integration should be aligned with the platform aspirations and the Book of Play","title":"01. Introduction and Goals"},{"location":"01.%20Introduction%20and%20Goals/#introduction-and-goals","text":"","title":"Introduction and Goals"},{"location":"01.%20Introduction%20and%20Goals/#vision","text":"\"Enable direct communication between users and agents for an improved service satisfaction\"","title":"Vision"},{"location":"01.%20Introduction%20and%20Goals/#requirements-overview","text":"","title":"Requirements Overview"},{"location":"01.%20Introduction%20and%20Goals/#why","text":"Improve user satisfaction by enabling them to receive quick solutions for their problems Reduce the effort to create a new ticket for a customer / gather all required information to solve a ticket","title":"Why"},{"location":"01.%20Introduction%20and%20Goals/#how","text":"Reusing existing functionality to quickly create new processes Including in new POWA client","title":"How"},{"location":"01.%20Introduction%20and%20Goals/#what","text":"Integrate Messaging (former Smoope) into Processes","title":"What"},{"location":"01.%20Introduction%20and%20Goals/#quality-goals","text":"Priority Quality Goal Scenario 1 Configurability It should be easy to install and configure Messaging for/on customer environments 2 Monitoring The integration should provide logging and monitoring mechanism based on the \"Book of play\"","title":"Quality Goals"},{"location":"01.%20Introduction%20and%20Goals/#stakeholders","text":"Role/Name Contact Expectations Product Owner Halil Mandal Messaging is completely integrated in Processes and provides added value Platform Integration Manager Christian Pesch The integration should be aligned with the platform aspirations and the Book of Play","title":"Stakeholders"},{"location":"02.%20Architecture%20Constraints/","text":"Architecture Constraints Constraint Explanation Hybrid operation While Processes is currently operated mostly on-premise Messaging will be hosted and operated in our cloud environment, which leads to a hybrid approach Minimal configuration effort The Messaging integration should be usable out of the box with minimal configuration effort to have a quick adaption by our customers","title":"02. Architecture Constraints"},{"location":"02.%20Architecture%20Constraints/#architecture-constraints","text":"Constraint Explanation Hybrid operation While Processes is currently operated mostly on-premise Messaging will be hosted and operated in our cloud environment, which leads to a hybrid approach Minimal configuration effort The Messaging integration should be usable out of the box with minimal configuration effort to have a quick adaption by our customers","title":"Architecture Constraints"},{"location":"03.%20Context%20and%20scope/","text":"System Scope and Context Business Context User The user interacts with Messaging via a chat widget on the self-service portal. Agent The agent can chat with the user via the embedded Messaging and tries to solve his concern. He can then create / extend a process via Processes Messaging Messaging provides the chat as content for the new or extended process Processes Processes is in charge of displaying the processes and user information related to the user the chat is currently for. Technical Context Messaging Backend In the first version, the messaging backend is hosted in our public cloud infrastructure and connects via https to the customer system. POWA On the customer system, the new POWA client includes the messaging UI. Any communication with the parent context is based on events.","title":"03. Context and scope"},{"location":"03.%20Context%20and%20scope/#system-scope-and-context","text":"","title":"System Scope and Context"},{"location":"03.%20Context%20and%20scope/#business-context","text":"User The user interacts with Messaging via a chat widget on the self-service portal. Agent The agent can chat with the user via the embedded Messaging and tries to solve his concern. He can then create / extend a process via Processes Messaging Messaging provides the chat as content for the new or extended process Processes Processes is in charge of displaying the processes and user information related to the user the chat is currently for.","title":"Business Context"},{"location":"03.%20Context%20and%20scope/#technical-context","text":"Messaging Backend In the first version, the messaging backend is hosted in our public cloud infrastructure and connects via https to the customer system. POWA On the customer system, the new POWA client includes the messaging UI. Any communication with the parent context is based on events.","title":"Technical Context"},{"location":"04.%20Solution%20Strategy/","text":"Solution Strategy Contents. A short summary and explanation of the fundamental decisions and solution strategies, that shape the system\u2019s architecture. These include technology decisions decisions about the top-level decomposition of the system, e.g. usage of an architectural pattern or design pattern decisions on how to achieve key quality goals relevant organizational decisions, e.g. selecting a development process or delegating certain tasks to third parties. Motivation. These decisions form the cornerstones for your architecture. They are the basis for many other detailed decisions or implementation rules. Form. Keep the explanation of these key decisions short. Motivate what you have decided and why you decided that way, based upon your problem statement, the quality goals and key constraints. Refer to details in the following sections.","title":"04. Solution Strategy"},{"location":"04.%20Solution%20Strategy/#solution-strategy","text":"Contents. A short summary and explanation of the fundamental decisions and solution strategies, that shape the system\u2019s architecture. These include technology decisions decisions about the top-level decomposition of the system, e.g. usage of an architectural pattern or design pattern decisions on how to achieve key quality goals relevant organizational decisions, e.g. selecting a development process or delegating certain tasks to third parties. Motivation. These decisions form the cornerstones for your architecture. They are the basis for many other detailed decisions or implementation rules. Form. Keep the explanation of these key decisions short. Motivate what you have decided and why you decided that way, based upon your problem statement, the quality goals and key constraints. Refer to details in the following sections.","title":"Solution Strategy"},{"location":"05.%20Building%20Block%20View/","text":"Building Block View Content. The building block view shows the static decomposition of the system into building blocks (modules, components, subsystems, classes, interfaces, packages, libraries, frameworks, layers, partitions, tiers, functions, macros, operations, datas structures, \u2026) as well as their dependencies (relationships, associations, \u2026) This view is mandatory for every architecture documentation. In analogy to a house this is the floor plan . Motivation. Maintain an overview of your source code by making its structure understandable through abstraction. This allows you to communicate with your stakeholder on an abstract level without disclosing implementation details. Form. The building block view is a hierarchical collection of black boxes and white boxes (see figure below) and their descriptions. Level 1 is the white box description of the overall system together with black box descriptions of all contained building blocks. Level 2 zooms into some building blocks of level 1. Thus it contains the white box description of selected building blocks of level 1, together with black box descriptions of their internal building blocks. Level 3 zooms into selected building blocks of level 2, and so on. Whitebox Overall System Here you describe the decomposition of the overall system using the following white box template. It contains an overview diagram a motivation for the decomposition black box descriptions of the contained building blocks. For these we offer you alternatives: use one table for a short and pragmatic overview of all contained building blocks and their interfaces use a list of black box descriptions of the building blocks according to the black box template (see below). Depending on your choice of tool this list could be sub-chapters (in text files), sub-pages (in a Wiki) or nested elements (in a modeling tool). (optional:) important interfaces, that are not explained in the black box templates of a building block, but are very important for understanding the white box. Since there are so many ways to specify interfaces why do not provide a specific template for them. In the worst case you have to specify and describe syntax, semantics, protocols, error handling, restrictions, versions, qualities, necessary compatibilities and many things more. In the best case you will get away with examples or simple signatures. <Overview Diagram> Motivation : <text explanation> Contained Building Blocks : <Description of contained building block (black boxes)> Important Interfaces : <Description of important interfaces> Insert your explanations of black boxes from level 1: If you use tabular form you will only describe your black boxes with name and responsibility according to the following schema: Name Responsibility Black Box 1 <Text> Black Box 2 <Text> If you use a list of black box descriptions then you fill in a separate black box template for every important building block . Its headline is the name of the black box. <Name black box 1> Here you describe <black box 1> according the the following black box template: Purpose/Responsibility Interface(s), when they are not extracted as separate paragraphs. This interfaces may include qualities and performance characteristics. (Optional) Quality-/Performance characteristics of the black box, e.g.availability, run time behavior, \u2026. (Optional) directory/file location (Optional) Fulfilled requirements (if you need traceability to requirements). (Optional) Open issues/problems/risks <Purpose/Responsibility> <Interface(s)> <(Optional) Quality/Performance Characteristics> <(Optional) Directory/File Location> <(Optional) Fulfilled Requirements> <(optional) Open Issues/Problems/Risks> <Name black box 2> <black box template> <Name black box n> <black box template> <Name interface 1> \u2026 <Name interface m> Level 2 Here you can specify the inner structure of (some) building blocks from level 1 as white boxes. You have to decide which building blocks of your system are important enough to justify such a detailed description. Please prefer relevance over completeness. Specify important, surprising, risky, complex or volatile building blocks. Leave out normal, simple, boring or standardized parts of your system White Box <building block 1> \u2026describes the internal structure of building block 1 . <white box template> White Box <building block 2> <white box template> \u2026 White Box <building block m> <white box template> Level 3 Here you can specify the inner structure of (some) building blocks from level 2 as white boxes. When you need more detailed levels of your architecture please copy this part of arc42 for additional levels. White Box <_building block x.1_> Specifies the internal structure of building block x.1 . <white box template> White Box <_building block x.2_> <white box template> White Box <_building block y.1_> <white box template>","title":"05. Building Block View"},{"location":"05.%20Building%20Block%20View/#building-block-view","text":"Content. The building block view shows the static decomposition of the system into building blocks (modules, components, subsystems, classes, interfaces, packages, libraries, frameworks, layers, partitions, tiers, functions, macros, operations, datas structures, \u2026) as well as their dependencies (relationships, associations, \u2026) This view is mandatory for every architecture documentation. In analogy to a house this is the floor plan . Motivation. Maintain an overview of your source code by making its structure understandable through abstraction. This allows you to communicate with your stakeholder on an abstract level without disclosing implementation details. Form. The building block view is a hierarchical collection of black boxes and white boxes (see figure below) and their descriptions. Level 1 is the white box description of the overall system together with black box descriptions of all contained building blocks. Level 2 zooms into some building blocks of level 1. Thus it contains the white box description of selected building blocks of level 1, together with black box descriptions of their internal building blocks. Level 3 zooms into selected building blocks of level 2, and so on.","title":"Building Block View"},{"location":"05.%20Building%20Block%20View/#whitebox-overall-system","text":"Here you describe the decomposition of the overall system using the following white box template. It contains an overview diagram a motivation for the decomposition black box descriptions of the contained building blocks. For these we offer you alternatives: use one table for a short and pragmatic overview of all contained building blocks and their interfaces use a list of black box descriptions of the building blocks according to the black box template (see below). Depending on your choice of tool this list could be sub-chapters (in text files), sub-pages (in a Wiki) or nested elements (in a modeling tool). (optional:) important interfaces, that are not explained in the black box templates of a building block, but are very important for understanding the white box. Since there are so many ways to specify interfaces why do not provide a specific template for them. In the worst case you have to specify and describe syntax, semantics, protocols, error handling, restrictions, versions, qualities, necessary compatibilities and many things more. In the best case you will get away with examples or simple signatures. <Overview Diagram> Motivation : <text explanation> Contained Building Blocks : <Description of contained building block (black boxes)> Important Interfaces : <Description of important interfaces> Insert your explanations of black boxes from level 1: If you use tabular form you will only describe your black boxes with name and responsibility according to the following schema: Name Responsibility Black Box 1 <Text> Black Box 2 <Text> If you use a list of black box descriptions then you fill in a separate black box template for every important building block . Its headline is the name of the black box.","title":"Whitebox Overall System"},{"location":"05.%20Building%20Block%20View/#name-black-box-1","text":"Here you describe <black box 1> according the the following black box template: Purpose/Responsibility Interface(s), when they are not extracted as separate paragraphs. This interfaces may include qualities and performance characteristics. (Optional) Quality-/Performance characteristics of the black box, e.g.availability, run time behavior, \u2026. (Optional) directory/file location (Optional) Fulfilled requirements (if you need traceability to requirements). (Optional) Open issues/problems/risks <Purpose/Responsibility> <Interface(s)> <(Optional) Quality/Performance Characteristics> <(Optional) Directory/File Location> <(Optional) Fulfilled Requirements> <(optional) Open Issues/Problems/Risks>","title":"&lt;Name black box 1&gt;"},{"location":"05.%20Building%20Block%20View/#name-black-box-2","text":"<black box template>","title":"&lt;Name black box 2&gt;"},{"location":"05.%20Building%20Block%20View/#name-black-box-n","text":"<black box template>","title":"&lt;Name black box n&gt;"},{"location":"05.%20Building%20Block%20View/#name-interface-1","text":"\u2026","title":"&lt;Name interface 1&gt;"},{"location":"05.%20Building%20Block%20View/#name-interface-m","text":"","title":"&lt;Name interface m&gt;"},{"location":"05.%20Building%20Block%20View/#level-2","text":"Here you can specify the inner structure of (some) building blocks from level 1 as white boxes. You have to decide which building blocks of your system are important enough to justify such a detailed description. Please prefer relevance over completeness. Specify important, surprising, risky, complex or volatile building blocks. Leave out normal, simple, boring or standardized parts of your system","title":"Level 2"},{"location":"05.%20Building%20Block%20View/#white-box-building-block-1","text":"\u2026describes the internal structure of building block 1 . <white box template>","title":"White Box &lt;building block 1&gt;"},{"location":"05.%20Building%20Block%20View/#white-box-building-block-2","text":"<white box template> \u2026","title":"White Box &lt;building block 2&gt;"},{"location":"05.%20Building%20Block%20View/#white-box-building-block-m","text":"<white box template>","title":"White Box &lt;building block m&gt;"},{"location":"05.%20Building%20Block%20View/#level-3","text":"Here you can specify the inner structure of (some) building blocks from level 2 as white boxes. When you need more detailed levels of your architecture please copy this part of arc42 for additional levels.","title":"Level 3"},{"location":"05.%20Building%20Block%20View/#white-box-_building-block-x1_","text":"Specifies the internal structure of building block x.1 . <white box template>","title":"White Box &lt;_building block x.1_&gt;"},{"location":"05.%20Building%20Block%20View/#white-box-_building-block-x2_","text":"<white box template>","title":"White Box &lt;_building block x.2_&gt;"},{"location":"05.%20Building%20Block%20View/#white-box-_building-block-y1_","text":"<white box template>","title":"White Box &lt;_building block y.1_&gt;"},{"location":"06.%20Runtime%20View/","text":"Runtime View Contents. The runtime view describes concrete behavior and interactions of the system\u2019s building blocks in form of scenarios from the following areas: important use cases or features: how do building blocks execute them? interactions at critical external interfaces: how do building blocks cooperate with users and neighboring systems? operation and administration: launch, start-up, stop error and exception scenarios Remark: The main criterion for the choice of possible scenarios (sequences, workflows) is their architectural relevance . It is not important to describe a large number of scenarios. You should rather document a representative selection. Motivation. You should understand how (instances of) building blocks of your system perform their job and communicate at runtime. You will mainly capture scenarios in your documentation to communicate your architecture to stakeholders that are less willing or able to read and understand the static models (building block view, deployment view). Form. There are many notations for describing scenarios, e.g. numbered list of steps (in natural language) activity diagrams or flow charts sequence diagrams BPMN or EPCs (event process chains) state machines \u2026 <Runtime Scenario 1> <insert runtime diagram or textual description of the scenario> <insert description of the notable aspects of the interactions between the building block instances depicted in this diagram.> <Runtime Scenario 2> ... <Runtime Scenario n> ...","title":"06. Runtime View"},{"location":"06.%20Runtime%20View/#runtime-view","text":"Contents. The runtime view describes concrete behavior and interactions of the system\u2019s building blocks in form of scenarios from the following areas: important use cases or features: how do building blocks execute them? interactions at critical external interfaces: how do building blocks cooperate with users and neighboring systems? operation and administration: launch, start-up, stop error and exception scenarios Remark: The main criterion for the choice of possible scenarios (sequences, workflows) is their architectural relevance . It is not important to describe a large number of scenarios. You should rather document a representative selection. Motivation. You should understand how (instances of) building blocks of your system perform their job and communicate at runtime. You will mainly capture scenarios in your documentation to communicate your architecture to stakeholders that are less willing or able to read and understand the static models (building block view, deployment view). Form. There are many notations for describing scenarios, e.g. numbered list of steps (in natural language) activity diagrams or flow charts sequence diagrams BPMN or EPCs (event process chains) state machines \u2026","title":"Runtime View"},{"location":"06.%20Runtime%20View/#runtime-scenario-1","text":"<insert runtime diagram or textual description of the scenario> <insert description of the notable aspects of the interactions between the building block instances depicted in this diagram.>","title":"&lt;Runtime Scenario 1&gt;"},{"location":"06.%20Runtime%20View/#runtime-scenario-2","text":"...","title":"&lt;Runtime Scenario 2&gt;"},{"location":"06.%20Runtime%20View/#runtime-scenario-n","text":"...","title":"&lt;Runtime Scenario n&gt;"},{"location":"07.%20Deployment%20View/","text":"Deployment View Content. The deployment view describes: the technical infrastructure used to execute your system, with infrastructure elements like geographical locations, environments, computers, processors, channels and net topologies as well as other infrastructure elements and the mapping of (software) building blocks to that infrastructure elements. Often systems are executed in different environments, e.g. development environment, test environment, production environment. In such cases you should document all relevant environments. Especially document the deployment view when your software is executed as distributed system with more then one computer, processor, server or container or when you design and construct your own hardware processors and chips. From a software perspective it is sufficient to capture those elements of the infrastructure that are needed to show the deployment of your building blocks. Hardware architects can go beyond that and describe the infrastructure to any level of detail they need to capture. Motivation. Software does not run without hardware. This underlying infrastructure can and will influence your system and/or some cross-cutting concepts. Therefore, you need to know the infrastructure. Maybe the highest level deployment diagram is already contained in section 3.2. as technical context with your own infrastructure as ONE black box. In this section you will zoom into this black box using additional deployment diagrams: UML offers deployment diagrams to express that view. Use it, probably with nested diagrams, when your infrastructure is more complex. When your (hardware) stakeholders prefer other kinds of diagrams rather than the deployment diagram, let them use any kind that is able to show nodes and channels of the infrastructure. Infrastructure Level 1 Describe (usually in a combination of diagrams, tables, and text): the distribution of your system to multiple locations, environments, computers, processors, .. as well as the physical connections between them important justification or motivation for this deployment structure Quality and/or performance features of the infrastructure the mapping of software artifacts to elements of the infrastructure For multiple environments or alternative deployments please copy that section of arc42 for all relevant environments. <Overview Diagram> Motivation : <explanation in text form> Quality and/or Performance Features : <explanation in text form> Mapping of Building Blocks to Infrastructure : <description of the mapping> Infrastructure Level 2 Here you can include the internal structure of (some) infrastructure elements from level 1. Please copy the structure from level 1 for each selected element. <Infrastructure Element 1> <diagram + explanation> <Infrastructure Element 2> <diagram + explanation> \u2026 <Infrastructure Element n> <diagram + explanation>","title":"07. Deployment View"},{"location":"07.%20Deployment%20View/#deployment-view","text":"Content. The deployment view describes: the technical infrastructure used to execute your system, with infrastructure elements like geographical locations, environments, computers, processors, channels and net topologies as well as other infrastructure elements and the mapping of (software) building blocks to that infrastructure elements. Often systems are executed in different environments, e.g. development environment, test environment, production environment. In such cases you should document all relevant environments. Especially document the deployment view when your software is executed as distributed system with more then one computer, processor, server or container or when you design and construct your own hardware processors and chips. From a software perspective it is sufficient to capture those elements of the infrastructure that are needed to show the deployment of your building blocks. Hardware architects can go beyond that and describe the infrastructure to any level of detail they need to capture. Motivation. Software does not run without hardware. This underlying infrastructure can and will influence your system and/or some cross-cutting concepts. Therefore, you need to know the infrastructure. Maybe the highest level deployment diagram is already contained in section 3.2. as technical context with your own infrastructure as ONE black box. In this section you will zoom into this black box using additional deployment diagrams: UML offers deployment diagrams to express that view. Use it, probably with nested diagrams, when your infrastructure is more complex. When your (hardware) stakeholders prefer other kinds of diagrams rather than the deployment diagram, let them use any kind that is able to show nodes and channels of the infrastructure.","title":"Deployment View"},{"location":"07.%20Deployment%20View/#infrastructure-level-1","text":"Describe (usually in a combination of diagrams, tables, and text): the distribution of your system to multiple locations, environments, computers, processors, .. as well as the physical connections between them important justification or motivation for this deployment structure Quality and/or performance features of the infrastructure the mapping of software artifacts to elements of the infrastructure For multiple environments or alternative deployments please copy that section of arc42 for all relevant environments. <Overview Diagram> Motivation : <explanation in text form> Quality and/or Performance Features : <explanation in text form> Mapping of Building Blocks to Infrastructure : <description of the mapping>","title":"Infrastructure Level 1"},{"location":"07.%20Deployment%20View/#infrastructure-level-2","text":"Here you can include the internal structure of (some) infrastructure elements from level 1. Please copy the structure from level 1 for each selected element.","title":"Infrastructure Level 2"},{"location":"07.%20Deployment%20View/#infrastructure-element-1","text":"<diagram + explanation>","title":"&lt;Infrastructure Element 1&gt;"},{"location":"07.%20Deployment%20View/#infrastructure-element-2","text":"<diagram + explanation> \u2026","title":"&lt;Infrastructure Element 2&gt;"},{"location":"07.%20Deployment%20View/#infrastructure-element-n","text":"<diagram + explanation>","title":"&lt;Infrastructure Element n&gt;"},{"location":"08.%20Crosscutting%20Concepts/","text":"Cross-cutting Concepts Content. This section describes overall, principal regulations and solution ideas that are relevant in multiple parts (= cross-cutting) of your system. Such concepts are often related to multiple building blocks. They can include many different topics, such as domain models architecture patterns or design patterns rules for using specific technology principal, often technical decisions of overall decisions implementation rules Motivation. Concepts form the basis for conceptual integrity (consistency, homogeneity) of the architecture. Thus, they are an important contribution to achieve inner qualities of your system. Some of these concepts cannot be assigned to individual building blocks (e.g. security or safety). This is the place in the template that we provided for a cohesive specification of such concepts. Form. The form can be varied: concept papers with any kind of structure cross-cutting model excerpts or scenarios using notations of the architecture views sample implementations, especially for technical concepts reference to typical usage of standard frameworks (e.g. using Hibernate for object/relational mapping) Structure. A potential (but not mandatory) structure for this section could be: Domain concepts User Experience concepts (UX) Safety and security concepts Architecture and design patterns \"Under-the-hood\" development concepts operational concepts Note: it might be difficult to assign individual concepts to one specific topic on this list. <Concept 1> <explanation> <Concept 2> <explanation> \u2026 <Concept n> <explanation>","title":"08. Crosscutting Concepts"},{"location":"08.%20Crosscutting%20Concepts/#cross-cutting-concepts","text":"Content. This section describes overall, principal regulations and solution ideas that are relevant in multiple parts (= cross-cutting) of your system. Such concepts are often related to multiple building blocks. They can include many different topics, such as domain models architecture patterns or design patterns rules for using specific technology principal, often technical decisions of overall decisions implementation rules Motivation. Concepts form the basis for conceptual integrity (consistency, homogeneity) of the architecture. Thus, they are an important contribution to achieve inner qualities of your system. Some of these concepts cannot be assigned to individual building blocks (e.g. security or safety). This is the place in the template that we provided for a cohesive specification of such concepts. Form. The form can be varied: concept papers with any kind of structure cross-cutting model excerpts or scenarios using notations of the architecture views sample implementations, especially for technical concepts reference to typical usage of standard frameworks (e.g. using Hibernate for object/relational mapping) Structure. A potential (but not mandatory) structure for this section could be: Domain concepts User Experience concepts (UX) Safety and security concepts Architecture and design patterns \"Under-the-hood\" development concepts operational concepts Note: it might be difficult to assign individual concepts to one specific topic on this list.","title":"Cross-cutting Concepts"},{"location":"08.%20Crosscutting%20Concepts/#concept-1","text":"<explanation>","title":"&lt;Concept 1&gt;"},{"location":"08.%20Crosscutting%20Concepts/#concept-2","text":"<explanation> \u2026","title":"&lt;Concept 2&gt;"},{"location":"08.%20Crosscutting%20Concepts/#concept-n","text":"<explanation>","title":"&lt;Concept n&gt;"},{"location":"09.%20Architecture%20Decisions/","text":"Architecture and Design Decisions Below an overview of all architecture design records (ADRs) Decision Date of decision (YYYY-MM-DD) OpenId Connect Token Forwarding 2020-09-23","title":"09. Architecture Decisions"},{"location":"09.%20Architecture%20Decisions/#architecture-and-design-decisions","text":"Below an overview of all architecture design records (ADRs) Decision Date of decision (YYYY-MM-DD) OpenId Connect Token Forwarding 2020-09-23","title":"Architecture and Design Decisions"},{"location":"10.%20Quality%20Requirements/","text":"Quality Requirements Content. This section contains all quality requirements as quality tree with scenarios. The most important ones have already been described in section 1.2. (quality goals) Here you can also capture quality requirements with lesser priority, which will not create high risks when they are not fully achieved. Motivation. Since quality requirements will have a lot of influence on architectural decisions you should know for every stakeholder what is really important to them, concrete and measurable. Quality Tree Content. The quality tree (as defined in ATAM \u2013 Architecture Tradeoff Analysis Method) with quality/evaluation scenarios as leafs. Motivation. The tree structure with priorities provides an overview for a sometimes large number of quality requirements. Form. The quality tree is a high-level overview of the quality goals and requirements: tree-like refinement of the term \"quality\". Use \"quality\" or \"usefulness\" as a root a mind map with quality categories as main branches In any case the tree should include links to the scenarios of the following section. Quality Scenarios Contents. Concretization of (sometimes vague or implicit) quality requirements using (quality) scenarios. These scenarios describe what should happen when a stimulus arrives at the system. For architects, two kinds of scenarios are important: Usage scenarios (also called application scenarios or use case scenarios) describe the system\u2019s runtime reaction to a certain stimulus. This also includes scenarios that describe the system\u2019s efficiency or performance. Example: The system reacts to a user\u2019s request within one second. Change scenarios describe a modification of the system or of its immediate environment. Example: Additional functionality is implemented or requirements for a quality attribute change. Motivation. Scenarios make quality requirements concrete and allow to more easily measure or decide whether they are fulfilled. Especially when you want to assess your architecture using methods like ATAM you need to describe your quality goals (from section 1.2) more precisely down to a level of scenarios that can be discussed and evaluated. Form. Tabular or free form text.","title":"10. Quality Requirements"},{"location":"10.%20Quality%20Requirements/#quality-requirements","text":"Content. This section contains all quality requirements as quality tree with scenarios. The most important ones have already been described in section 1.2. (quality goals) Here you can also capture quality requirements with lesser priority, which will not create high risks when they are not fully achieved. Motivation. Since quality requirements will have a lot of influence on architectural decisions you should know for every stakeholder what is really important to them, concrete and measurable.","title":"Quality Requirements"},{"location":"10.%20Quality%20Requirements/#quality-tree","text":"Content. The quality tree (as defined in ATAM \u2013 Architecture Tradeoff Analysis Method) with quality/evaluation scenarios as leafs. Motivation. The tree structure with priorities provides an overview for a sometimes large number of quality requirements. Form. The quality tree is a high-level overview of the quality goals and requirements: tree-like refinement of the term \"quality\". Use \"quality\" or \"usefulness\" as a root a mind map with quality categories as main branches In any case the tree should include links to the scenarios of the following section.","title":"Quality Tree"},{"location":"10.%20Quality%20Requirements/#quality-scenarios","text":"Contents. Concretization of (sometimes vague or implicit) quality requirements using (quality) scenarios. These scenarios describe what should happen when a stimulus arrives at the system. For architects, two kinds of scenarios are important: Usage scenarios (also called application scenarios or use case scenarios) describe the system\u2019s runtime reaction to a certain stimulus. This also includes scenarios that describe the system\u2019s efficiency or performance. Example: The system reacts to a user\u2019s request within one second. Change scenarios describe a modification of the system or of its immediate environment. Example: Additional functionality is implemented or requirements for a quality attribute change. Motivation. Scenarios make quality requirements concrete and allow to more easily measure or decide whether they are fulfilled. Especially when you want to assess your architecture using methods like ATAM you need to describe your quality goals (from section 1.2) more precisely down to a level of scenarios that can be discussed and evaluated. Form. Tabular or free form text.","title":"Quality Scenarios"},{"location":"11.%20Risks%20and%20Technical%20Debt/","text":"Risks and Technical Debts Contents. A list of identified technical risks or technical debts, ordered by priority Motivation. \u201cRisk management is project management for grown-ups\u201d (Tim Lister, Atlantic Systems Guild.) This should be your motto for systematic detection and evaluation of risks and technical debts in the architecture, which will be needed by management stakeholders (e.g. project managers, product owners) as part of the overall risk analysis and measurement planning. Form. List of risks and/or technical debts, probably including suggested measures to minimize, mitigate or avoid risks or reduce technical debts.","title":"11. Risks and Technical Debt"},{"location":"11.%20Risks%20and%20Technical%20Debt/#risks-and-technical-debts","text":"Contents. A list of identified technical risks or technical debts, ordered by priority Motivation. \u201cRisk management is project management for grown-ups\u201d (Tim Lister, Atlantic Systems Guild.) This should be your motto for systematic detection and evaluation of risks and technical debts in the architecture, which will be needed by management stakeholders (e.g. project managers, product owners) as part of the overall risk analysis and measurement planning. Form. List of risks and/or technical debts, probably including suggested measures to minimize, mitigate or avoid risks or reduce technical debts.","title":"Risks and Technical Debts"},{"location":"12.%20Glossary/","text":"Glossary Contents. The most important domain and technical terms that your stakeholders use when discussing the system. You can also see the glossary as source for translations if you work in multi-language teams. Motivation. You should clearly define your terms, so that all stakeholders have an identical understanding of these terms do not use synonyms and homonyms Form. A table with columns <Term> and <Definition>. Potentially more columns in case you need translations. Term Definition Term 1 <definition-1> Term 2 <definition-2>","title":"12. Glossary"},{"location":"12.%20Glossary/#glossary","text":"Contents. The most important domain and technical terms that your stakeholders use when discussing the system. You can also see the glossary as source for translations if you work in multi-language teams. Motivation. You should clearly define your terms, so that all stakeholders have an identical understanding of these terms do not use synonyms and homonyms Form. A table with columns <Term> and <Definition>. Potentially more columns in case you need translations. Term Definition Term 1 <definition-1> Term 2 <definition-2>","title":"Glossary"},{"location":"adrs/adr-000%20-%20ADR%20Template/","text":"# [short title of solved problem and solution] Status: [proposed | rejected | accepted | deprecated | \u2026 | superseded by ADR-0005 ] Deciders: [list everyone involved in the decision] Date: [YYYY-MM-DD when the decision was last updated] Technical Story: [description | ticket/issue URL] ## Context and Problem Statement [Describe the context and problem statement, e.g., in free form using two to three sentences. You may want to articulate the problem in form of a question.] ## Decision Drivers [driver 1, e.g., a force, facing concern, \u2026] [driver 2, e.g., a force, facing concern, \u2026] \u2026 ## Considered Options #### Option 1 #### Option 2 #### Option 3 ## Decision Outcome Chosen option: \"[option 1]\", because [justification. e.g., only option, which meets k.o. criterion decision driver | which resolves force force | \u2026 | comes out best (see below)]. ### Positive Consequences [e.g., improvement of quality attribute satisfaction, follow-up decisions required, \u2026] \u2026 ### Negative Consequences [e.g., compromising quality attribute, follow-up decisions required, \u2026] \u2026 ## Pros and Cons of the Options ### Option 1 [example | description | pointer to more information | \u2026] Good, because [argument a] Good, because [argument b] Bad, because [argument c] \u2026 ### Option 2 [example | description | pointer to more information | \u2026] Good, because [argument a] Good, because [argument b] Bad, because [argument c] \u2026 ### Option 3 [example | description | pointer to more information | \u2026] Good, because [argument a] Good, because [argument b] Bad, because [argument c] \u2026 ## Links [Link type] [Link to ADR] \u2026","title":"[short title of solved problem and solution]"},{"location":"adrs/adr-001%20-%20OpenId%20Connect%20Token%20Forwarding/","text":"# OpenId Connect Token forwarding to embedded iFrame Status: open Deciders: Christian Schulz, \u00d6mer Yildiz, Marius Schulze Date: 2020-09-23 Technical Story: https://tfs.pmcs-helpline.com/tfs/Helpline/HelpLineScrum/_workitems/edit/209123 ## Context and Problem Statement When embedding the messaging UI via an iFrame, how can we pass the OpenId connect token to the messaging component? The user should not need to login again. ## Decision Drivers Common POWA infrastructure Security concerns on how to pass the oic token in a secure manner ## Considered Options #### Option 1 Event-based communication with Window.postMessage() #### Option 2 Passing the token via URL ## Decision Outcome The Option 1 is the recommended way to communicate securely between a page and an embedded iFrame. We will stick to this approach as it is already used in production by Messaging. ## Pros and Cons of the Options ### Option 1 The token gets passed to the embedded module via Window.postMessage() . Inside of the iFrame the Messaging module listens to the message bus and verifies if the event origin is trusted to validate the sender's identity. Good, because it is the recommended way to communicate between a page and an iFrame. Good, because it is already used by Messaging in production. The data structure for the serialized message will be: interface SerializedMessage { type: string; data: Record<string, any>; } The type that was agreed on with the Messaging team is: TOKEN_CHANGE_TYPE = 'TokenChange'; ### Option 2 The token gets passed as a query parameter of the url to the iFrame. Good, because the implementation is easy and the current prototype already contains this functionality. Bad, because the token is then easily interceptable.","title":"OpenId Connect Token forwarding to embedded iFrame"},{"location":"adrs/adr-002%20-%20Adding%20chat%20and%20attachment%20information%20to%20a%20new%20ticket/","text":"# Adding chat and attachment information to a new ticket Status: accepted Deciders: Christian Schulz, \u00d6mer Yildiz, Victor Mosin, Marc Schmidt, Nima Hamidian, Philip Koep, Jens Schmitz, Marius Schulze Date: 2020-10-06 Technical Story: https://tfs.pmcs-helpline.com/tfs/Helpline/HelpLineScrum/_workitems/edit/202886 ## Context and Problem Statement When the agent creates a new ticket out of a chat, how is the chat added to the new ticket? Will it be visible to the agent or will it be added on the server-side? ## Decision Drivers The chat content and especially the attachments can have a decent storage size. When integrated on the client it will need data volume to transfer them from the messaging backend to the processes client to send it to the processes backend. ## Considered Options #### Option 1 Client-side integration (Message Bus) #### Option 2 Client-side integration (API call) #### Option 3 Server-side integration ## Decision Outcome Chosen option: Option 3 , because large content doesn't need to be transferred to the client but is queried via server-server communication. ## Pros and Cons of the Options ### Option 1 The messaging component receives the chat content and attachments from the embedded iframe via event-based communication. It will display the chat inside the first multiline text field and the attachments are added to the first attachment control. Good, because the agent can see and modify the chat content when creating a ticket. Bad, because lots of data has to be transferred via events which might not be the intended use case. Bad, because a lot of data volume would be consumed. ### Option 2 The chat content and attachments are loaded via an API from the messaging backend instead of an event-based communication. Good, because the agent can see and modify the chat content when creating a ticket. Good, because an API call is better for loading data from the backend than passing it via events. Bad, because a lot of data volume would be consumed. ### Option 3 The chat content and the attachments are exchanged between the processes server and messaging server. The client only displays information that the chat and attachments will be added to the ticket automatically. The POWA client receives the current chat ID from the iframe. The processes server queries the needed content from the messaging server. The attachments could be added only via a link so there is no data duplication. This needs to be decided in another ADR. Good, because the client doesn't need to handle large data. Good, because server-to-server communication would be done asynchronous so the agent doesn't have to wait for the data to be loaded. Bad, because the agent doesn't see the chat in the popup dialog.","title":"Adding chat and attachment information to a new ticket"}]}